/** * @class Array *//** * Function to check if a string is in array * @param {*} the parameter to find * @return {Number} count the number of occurence or 0 */Array.prototype.is_in_array = function (parameter) {    var count = 0;    for (x in this) {        if (parameter === this[x]) {            count++;        }    }    return count;}/** * Function to return the lower number in an array * @return {Number} lowest_number the lower number in the array */Array.prototype.min = function () {    return Math.min.apply(null, this);}/** * Function to return the bigger number in an array * @return {Number} bigger_number the bigger number in the array */Array.prototype.max = function () {    return Math.max.apply(null, this);}/** * Function to execute a foreach loop on an array * {@link https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach | Mozilla developper network forEach} * @param callback Function to execute on each element * @param thisArg object to use as this (the object to edit) * @example * * function logArrayElements(element, index, array) { *   console.log("a[" + index + "] = " + element); * } * [2, 5, 9].forEach(logArrayElements); * // logs: * // a[0] = 2 * // a[1] = 5 * // a[2] = 9 * * * var myArray = ['toto','samantha']; * var myArray2 = []; * * // fonction de callback * function makeArray(element,index){ *  this[index] = element.toUpperCase(); * } * * // forEach prend en 2ème paramètre, un 2ème tableau : myArray2 * myArray.forEach(makeArray,myArray2); * * console.log(myArray2); * // affiche ['TOTO','SAMANTHA'] * * console.log(myArray); * // affiche ['toto','samantha'] * // myArray n'a pas été modifié */Array.prototype.forEach = function forEach (callback, thisArg) {    'use strict';    var T, k;    if (this == null) {        throw new TypeError("this is null or not defined");    }    var kValue,    // 1. Let O be the result of calling ToObject passing the |this| value as the argument.        O = Object(this),    // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).        len = O.length >>> 0; // Hack to convert O.length to a UInt32    // 4. If IsCallable(callback) is false, throw a TypeError exception.    // See: http://es5.github.com/#x9.11    if ({}.toString.call(callback) !== "[object Function]") {        throw new TypeError(callback + " is not a function");    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length >= 2) {        T = thisArg;    }    // 6. Let k be 0    k = 0;    // 7. Repeat, while k < len    while (k < len) {        // a. Let Pk be ToString(k).        //   This is implicit for LHS operands of the in operator        // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.        //   This step can be combined with c        // c. If kPresent is true, then        if (k in O) {            // i. Let kValue be the result of calling the Get internal method of O with argument Pk.            kValue = O[k];            // ii. Call the Call internal method of callback with T as the this value and            // argument list containing kValue, k, and O.            callback.call(T, kValue, k, O);        }        // d. Increase k by 1.        k++;    }    // 8. return undefined}